package imutil

import (
	"bytes"
	"compress/zlib"
	"encoding/hex"
	"fmt"
	"io"

	"github.com/jnschaeffer/cve-2022-44268-detector/internal/image/png"
)

// WritePNGChunkTo modes.
const (
	WRaw                 = "raw"
	WDecompress          = "decompress"
	WDecompressHexdecode = WDecompress + "-hexdecode"
)

func WriteChunkTo(chunk *png.TextChunk, writer io.Writer, mode string) error {
	reader := io.NopCloser(bytes.NewReader(chunk.Value))

	if (mode == WDecompress || mode == WDecompressHexdecode) && chunk.Compressed {
		zlibReader, err := zlib.NewReader(reader)
		if err != nil {
			return err
		}
		defer zlibReader.Close()

		reader = zlibReader

		err = discardWeirdHeaderGarbage(reader)
		if err != nil {
			return fmt.Errorf("failed to discard weird header garbage - %w", err)
		}

		if mode == WDecompressHexdecode {
			// For whatever reason, imagemagick hex-encodes the
			// chunk's value... and then adds new lines after 72
			// characters. Thus, we need to filter the newlines.
			reader = io.NopCloser(hex.NewDecoder(&discardNewLinesReader{
				r: reader,
			}))
		}
	}

	_, err := io.Copy(writer, reader)
	if err != nil {
		return err
	}

	return nil
}

// discardWeirdHeaderGarbage discards the weird header garbage that
// imagetragic includes in zTXt chunks (this header appears at the
// beginning of the decompressed data). The header's values appear
// to be newline delimited. The last value in the header appears to
// be the length of the hex-encoded data.
//
//	# Note: "267" here is the length of the hex-encoded data.
//	$ hexdump -C /tmp/out
//	00000000  0a 0a 20 20 20 20 20 32  36 37 0a 41 41 41 41 41  |..     267.AAAAA|
func discardWeirdHeaderGarbage(r io.Reader) error {
	numNewLines := 0
	b := make([]byte, 1)

	for {
		_, err := r.Read(b)
		if err != nil {
			return err
		}

		if b[0] == 0x0a {
			numNewLines++

			if numNewLines == 3 {
				return nil
			}
		}
	}
}

// discardNewLinesReader discards any newline (0x0a) characters.
// It is unbuffered... so, it sucks.
type discardNewLinesReader struct {
	r io.Reader
}

func (o *discardNewLinesReader) Read(p []byte) (int, error) {
	b := make([]byte, 1)
	numWrites := 0

	for {
		_, err := o.r.Read(b)
		if err != nil {
			return numWrites, err
		}

		if b[0] != 0x0a {
			p[numWrites] = b[0]
			numWrites++
		}

		if numWrites == len(p) {
			return numWrites, nil
		}
	}
}
