// pluck attempts to parse all the files in a directory as pngs and extracts
// any tEXt and zTXt chunks matching a regex into an output directory.
package main

import (
	"context"
	"errors"
	"flag"
	"fmt"
	"log"
	"os"
	"os/exec"
	"os/signal"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/jnschaeffer/cve-2022-44268-detector/internal/image/png"
	"github.com/jnschaeffer/cve-2022-44268-detector/internal/imutil"
)

var (
	errNoIOCFound = errors.New("no potential indicators of compromise found")
)

func main() {
	log.SetFlags(0)

	err := mainWithError()
	if err != nil {
		log.Println("error:", err)

		if errors.Is(err, errNoIOCFound) {
			os.Exit(10)
		}

		os.Exit(1)
	}
}

func mainWithError() error {
	keywordRegexStr := flag.String(
		"k",
		"^Raw profile type$",
		"Regex to match png chunk keyword")
	inputDirPath := flag.String(
		"i",
		"",
		"Directory containing png files to parse")
	outputDirPath := flag.String(
		"o",
		"",
		"Output directory path")
	shouldHexdump := flag.Bool(
		"x",
		false,
		"Execute 'hexdump -C' on matched png chunks and save to file")

	flag.Parse()

	var err error
	flag.VisitAll(func(f *flag.Flag) {
		if err != nil {
			return
		}

		if f.Value.String() == "" && !strings.HasPrefix(f.Usage, "Optional") {
			err = fmt.Errorf("please specify '-%s' - %s",
				f.Name, f.Usage)
		}
	})
	if err != nil {
		return err
	}

	ctx, cancelFn := signal.NotifyContext(context.Background(), os.Interrupt)
	defer cancelFn()

	keywordRegex, err := regexp.Compile(*keywordRegexStr)
	if err != nil {
		return fmt.Errorf("failed to parse png chunk keyword regex - %w", err)
	}

	fileInfos, err := os.ReadDir(*inputDirPath)
	if err != nil {
		return fmt.Errorf("failed to read input dir entries - %w", err)
	}

	detectionsDirPath := filepath.Join(*outputDirPath, "detections")

	detectionsDirInfo, _ := os.Stat(detectionsDirPath)
	if detectionsDirInfo != nil {
		if detectionsDirInfo.IsDir() {
			return fmt.Errorf("detections dir already exists at '%s'", detectionsDirPath)
		}

		return fmt.Errorf("detections dir is a file ('%s')", detectionsDirPath)
	}

	var errs []string
	numDetections := 0
	numExamined := 0

	for _, info := range fileInfos {
		if info.IsDir() {
			continue
		}

		pngFilePath := filepath.Join(*inputDirPath, info.Name())

		foundAny, err := dump(ctx, &dumpConfig{
			PNGFilePath:  pngFilePath,
			KeywordRegex: keywordRegex,
			OutDirPath:   detectionsDirPath,
			ExecHexdump:  *shouldHexdump,
		})
		if err != nil {
			errs = append(errs, fmt.Sprintf("%s - %s",
				filepath.Base(pngFilePath), err))

			continue
		}

		if foundAny {
			numDetections++
		}

		numExamined++
	}

	log.Printf("detections: %d | examined %d | errors: %d",
		numDetections, numExamined, len(errs))

	if len(errs) > 0 {
		errsLogPath := filepath.Join(*outputDirPath, "errors.log")

		err = os.WriteFile(errsLogPath, []byte(strings.Join(errs, "\n")), 0600)
		if err != nil {
			return fmt.Errorf("failed to write errors log file '%s' - %s", errsLogPath, err)
		}

		return fmt.Errorf("encountered %d error(s) while dumping files - refer to '%s' for more info",
			len(errs), errsLogPath)
	}

	if numDetections == 0 {
		return errNoIOCFound
	}

	return nil
}

type dumpConfig struct {
	PNGFilePath  string
	KeywordRegex *regexp.Regexp
	OutDirPath   string
	ExecHexdump  bool
}

func dump(ctx context.Context, config *dumpConfig) (bool, error) {
	pngFile, err := os.Open(config.PNGFilePath)
	if err != nil {
		return false, err
	}
	defer pngFile.Close()

	chunks, err := png.FindTextChunks(pngFile)
	_ = pngFile.Close()
	if err != nil {
		return false, err
	}

	basename := filepath.Base(config.PNGFilePath)
	outDir := filepath.Join(config.OutDirPath, basename)
	numFound := 0

	for _, chunk := range chunks {
		if !config.KeywordRegex.MatchString(chunk.Keyword) {
			continue
		}

		if numFound == 0 {
			err = os.MkdirAll(outDir, 0700)
			if err != nil {
				return false, fmt.Errorf("failed to create output dir for png file - %w", err)
			}
		}

		outputFilePath := filepath.Join(
			outDir,
			fmt.Sprintf("chunk-%d-0x%x", numFound, chunk.Offset))

		err = os.WriteFile(
			outputFilePath+"-info.txt",
			[]byte(chunkInfoString(numFound, &chunk)),
			0600)
		if err != nil {
			return false, fmt.Errorf("failed to write summary file for chunk index %d - %w",
				numFound, err)
		}

		chunkBinPath := outputFilePath + ".bin"

		err = writeChunkToFile(&chunk, chunkBinPath)
		if err != nil {
			return false, fmt.Errorf("failed to save chunk index %d to file - %w",
				numFound, err)
		}

		if config.ExecHexdump {
			err = execHexdump(ctx, execHexdumpConfig{
				OptHeader:  "",
				InputPath:  chunkBinPath,
				OutputPath: outputFilePath + "-hexdump.txt",
			})
			if err != nil {
				return false, fmt.Errorf("failed to hexdump chunk index %d - %w",
					numFound, err)
			}
		}

		numFound++
	}

	return numFound > 0, nil
}

func chunkInfoString(id int, chunk *png.TextChunk) string {
	return fmt.Sprintf("keyword='%s'\ncompressed=%t\nid=%d\noffset=0x%x\nlen=%d\n",
		chunk.Keyword, chunk.Compressed, id, chunk.Offset, len(chunk.Value))
}

func writeChunkToFile(chunk *png.TextChunk, filePath string) error {
	f, err := os.OpenFile(filePath, os.O_CREATE|os.O_WRONLY, 0600)
	if err != nil {
		return err
	}
	defer f.Close()

	return imutil.WriteChunkTo(chunk, f, imutil.WDecompressHexdecode)
}

type execHexdumpConfig struct {
	OptHeader  string
	InputPath  string
	OutputPath string
}

func execHexdump(ctx context.Context, config execHexdumpConfig) error {
	f, err := os.OpenFile(config.OutputPath, os.O_CREATE|os.O_WRONLY, 0600)
	if err != nil {
		return err
	}
	defer f.Close()

	if config.OptHeader != "" {
		_, err = f.WriteString(config.OptHeader + "\n")
		if err != nil {
			return err
		}
	}

	hexdump := exec.CommandContext(ctx, "hexdump", "-C", config.InputPath)
	hexdump.Stdout = f

	err = hexdump.Run()
	if err != nil {
		return err
	}

	return nil
}
