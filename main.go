package main

import (
	"flag"
	"fmt"
	"io"
	"log"
	"os"

	"github.com/jnschaeffer/cve-2022-44268-detector/internal/image/png"
)

const (
	// profileKeyword is the string that imagetragic appears to use for
	// the png chunk keyword containing leaked data. The code path is
	// not immediately obvious in the codebase, but dynamic analysis
	// appears to indicate it uses this string.
	//
	//	$ git status
	//	HEAD detached at 7.0.9-17
	//	nothing to commit, working tree clean
	//	$ git grep 'Raw profile type'
	//	coders/png.c:    We have already read "Raw profile type.
	//	coders/png.c:            memcmp(text[i].key, "Raw profile type ",17) == 0)
	//	coders/png.c:      "Raw profile type ",MagickPathExtent);
	profileKeyword = "Raw profile type"
)

var (
	filename      string
	printContents bool
)

func init() {
	flag.StringVar(&filename, "filename", "", "filename to parse (uses stdin if not set)")
	flag.BoolVar(&printContents, "print", false, "if set, write the png chunk's value to stdout. Note: This is likely\n"+
		"binary, zlib-compressed data. Refer to 'zTXt' in RFC 2083")
}

func findProfileChunk(chunks []png.TextChunk) (png.TextChunk, bool) {
	for _, chunk := range chunks {
		if chunk.Keyword == profileKeyword {
			return chunk, true
		}
	}

	return png.TextChunk{}, false
}

func main() {
	flag.Parse()

	var r io.Reader = os.Stdin
	if filename != "" {
		f, err := os.Open(filename)
		if err != nil {
			log.Fatal(err)
		}

		defer f.Close()

		r = f
	}

	chunks, err := png.FindTextChunks(r)
	if err != nil {
		log.Fatal(err)
	}

	chunk, found := findProfileChunk(chunks)
	if !found {
		fmt.Println("no profile chunk found. this image is likely not malicious")

		// Exit with status code 1 here - technically not finding anything is a failure
		os.Exit(1)
	}

	log.Println("***PROFILE CHUNK FOUND! if this was found in a production system, update your dependencies immediately and inspect your systems for evidence of further compromise!***")

	if printContents {
		log.Println("chunk value:")
		_, err := os.Stdout.Write(chunk.Value)
		if err != nil {
			log.Fatal(err)
		}
	}
}
