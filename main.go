// cve-2022-44268-detector is a Go program that consumes PNGs and reports
// whether they appear to be malicious images generated by an exploit for
// CVE-2022-44268, an ImageMagick vulnerability that allows attackers to
// read arbitrary file contents using specially crafted images.
package main

import (
	"bytes"
	"compress/zlib"
	"encoding/hex"
	"errors"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"regexp"

	"github.com/jnschaeffer/cve-2022-44268-detector/internal/image/png"
)

const (
	// profileKeyword is the string that imagetragic appears to use for
	// the png chunk keyword containing leaked data. The code path is
	// not immediately obvious in the codebase, but dynamic analysis
	// appears to indicate it uses this string.
	//
	//	$ git status
	//	HEAD detached at 7.0.9-17
	//	nothing to commit, working tree clean
	//	$ git grep 'Raw profile type'
	//	coders/png.c:    We have already read "Raw profile type.
	//	coders/png.c:            memcmp(text[i].key, "Raw profile type ",17) == 0)
	//	coders/png.c:      "Raw profile type ",MagickPathExtent);
	profileKeyword = "Raw profile type"

	outputRaw                 = "raw"
	outputDecompress          = "decompress"
	outputDecompressHexdecode = outputDecompress + "-hexdecode"
)

var (
	filename      string
	printContents string
	keywordRegexS string
	debug         bool

	errNoIOCFound = errors.New("no potential indicators of compromise found")
)

func init() {
	flag.StringVar(&filename, "filename", "", "filename to parse (uses stdin if not set)")
	flag.StringVar(&printContents, "print", "",
		"if set, write each suspicious png chunk's value to stdout.\n"+
			"May specify: '"+outputRaw+"', '"+outputDecompress+"', '"+outputDecompressHexdecode+"'")
	flag.StringVar(&keywordRegexS, "keyword", "^"+profileKeyword+"$", "regex to match png chunk keyword")
	flag.BoolVar(&debug, "debug", false, "enable debug logging if set. The program will emit information about\n"+
		"unknown png chunk types")
}

func main() {
	flag.Parse()

	log.SetFlags(0)

	if debug {
		png.Debug = log.New(log.Writer(), "[debug] ", log.Flags()|log.Lmsgprefix)
	}

	switch printContents {
	case "", outputRaw, outputDecompress, outputDecompressHexdecode:
		// Permitted output values.
	default:
		log.Fatalf("unknown output mode: '%s'", printContents)
	}

	keywordRegex, err := regexp.Compile(keywordRegexS)
	if err != nil {
		log.Fatalf("failed to parse png chunk keyword regex - %s", err)
	}

	var r io.Reader = os.Stdin
	if filename != "" {
		f, err := os.Open(filename)
		if err != nil {
			log.Fatal(err)
		}

		defer f.Close()

		r = f
	}

	chunks, err := png.FindTextChunks(r)
	if err != nil {
		log.Fatal(err)
	}

	err = findChunks(keywordRegex, chunks)
	if err != nil {
		log.Println(err)

		if errors.Is(err, errNoIOCFound) {
			os.Exit(10)
		}

		os.Exit(1)
	}
}

func findChunks(keywordRegex *regexp.Regexp, chunks []png.TextChunk) error {
	numFound := 0

	for _, chunk := range chunks {
		if keywordRegex.MatchString(chunk.Keyword) {
			log.Printf("***POTENTIAL INDICATOR OF COMPROMISE*** - "+
				"keyword: '%s' | compressed: %t | id: %d | offset: 0x%x | len: %d",
				chunk.Keyword, chunk.Compressed, numFound, chunk.Offset, len(chunk.Value))

			if printContents != "" {
				err := writeChunkTo(&chunk, os.Stdout)
				if err != nil {
					return err
				}
			}

			numFound++
		}
	}

	if numFound == 0 {
		return errNoIOCFound
	}

	return nil
}

func writeChunkTo(chunk *png.TextChunk, writer io.Writer) error {
	reader := io.NopCloser(bytes.NewReader(chunk.Value))

	if (printContents == outputDecompress || printContents == outputDecompressHexdecode) && chunk.Compressed {
		zlibReader, err := zlib.NewReader(reader)
		if err != nil {
			return err
		}
		defer zlibReader.Close()

		reader = zlibReader

		err = discardWeirdHeaderGarbage(reader)
		if err != nil {
			return fmt.Errorf("failed to discard weird header garbage - %w", err)
		}

		if printContents == outputDecompressHexdecode {
			// For whatever reason, imagemagick hex-encodes the
			// chunk's value... and then adds new lines after 72
			// characters. Thus, we need to filter the newlines.
			reader = io.NopCloser(hex.NewDecoder(&discardNewLinesReader{
				r: reader,
			}))
		}
	}

	_, err := io.Copy(writer, reader)
	if err != nil {
		return err
	}

	return nil
}

// discardWeirdHeaderGarbage discards the weird header garbage that
// imagetragic includes in zTXt chunks (this header appears at the
// beginning of the decompressed data). The header's values appear
// to be newline delimited. The last value in the header appears to
// be the length of the hex-encoded data.
//
//	# Note: "267" here is the length of the hex-encoded data.
//	$ hexdump -C /tmp/out
//	00000000  0a 0a 20 20 20 20 20 32  36 37 0a 41 41 41 41 41  |..     267.AAAAA|
func discardWeirdHeaderGarbage(r io.Reader) error {
	numNewLines := 0
	b := make([]byte, 1)

	for {
		_, err := r.Read(b)
		if err != nil {
			return err
		}

		if b[0] == 0x0a {
			numNewLines++

			if numNewLines == 3 {
				return nil
			}
		}
	}
}

// discardNewLinesReader discards any newline (0x0a) characters.
// It is unbuffered... so, it sucks.
type discardNewLinesReader struct {
	r io.Reader
}

func (o *discardNewLinesReader) Read(p []byte) (int, error) {
	b := make([]byte, 1)
	numWrites := 0

	for {
		_, err := o.r.Read(b)
		if err != nil {
			return numWrites, err
		}

		if b[0] != 0x0a {
			p[numWrites] = b[0]
			numWrites++
		}

		if numWrites == len(p) {
			return numWrites, nil
		}
	}
}
